# -*- coding: utf-8 -*-
"""CCL-DB Message Frequencies.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-LLuQORuV42ylJtRylCTXFTa5_LBm3bg

# CCL.NET: Dashboard for Analysis of Message Posting Frequency

*(description pending)*

Instructions:

1. Click `Runtime` > `Run all` in the menu.
2. Click the `127.0.0.1` link that should appear in the last cell of the notebook.

# Install dependencies

The Google Colab instances don't include Dash or `jupyter-dash` by default. Installing `jupyter-dash` is enough to bring in all of the needed dependencies.
"""

# !pip install -U -q jupyter-dash

"""# Import Tools

We need `datetime`, `calendar`, `pandas`, `plotly`, `dash`, and `jupyter_dash`.

- `datetime` is part of the Python standard library and helps with date representation
- `calendar` is also part of the Python standard library, and makes it easy to find the last day of any given month
- `pandas` provides the `DataFrame` class for holding the timeseries data
- `numpy` provides some low-level array operations
- `plotly` is the plotting library underlying `dash`
- `dash` is a tool for creating interactive data dashboards
- `jupyter_dash` provides the machinery to render a Dash dashboard in Jupyter
"""

import calendar
import datetime

import numpy as np
import pandas as pd
import plotly.express as px
import dash
from dash import callback, Dash, dcc, html as dhtml
from dash.dependencies import Input, Output, State

dash.register_page(__name__)

"""# Retrieve Data

The data is hosted on Google Drive. These links point directly to CSV files of the yearly, monthly and daily message frequencies for CCL.
"""

df_yearly = pd.read_csv("https://drive.google.com/uc?id=19jZ62cQBMvoqQMHyzglsH-_r3JbF8KBQ")
df_monthly = pd.read_csv("https://drive.google.com/uc?id=1PHc1eGwOC6Bb1rPH1yL7tEuxVQH_DJ-m")
df_daily = pd.read_csv("https://drive.google.com/uc?id=1NpsgvbUjI_ahOy7z_n7RWeT_UOiTKK2v")
# df_monthly.tail()

"""# Add 'Date' Columns to Monthly and Daily Data

In order to plot the monthly and daily data, we need to have a single column with a suitable `datetime` value for each year/month and year/month/day combination.

## Define helper constants

These will simplify access to the 'date' and 'count' columns.
"""

COL_COUNT = "count"
COL_DATE = "date"

"""## Add the 'date' columns"""

df_monthly[COL_DATE] = pd.to_datetime(pd.concat([df_monthly[["year", "month"]], pd.DataFrame(np.ones(len(df_monthly.index), dtype=int), columns=["day"])], axis="columns"))
df_daily[COL_DATE] = pd.to_datetime(df_daily[["year", "month", "day"]])

d = df_daily.iloc[0]['date']
pd.Timestamp(year=d.year, month=d.month, day=calendar.monthrange(year=d.year, month=d.month)[1])

"""# Create the Dash app

Dash lets you create visualization dashboards with interconnected controls and plots. Here, because of the size of the dataset, it's not practical to plot all of the daily data. So, this Dash app shows you all of the data per-month, and lets you choose a range of data to show per-day.

## Define helper constants

Instead of using explicit strings to name and refer to all of the pieces of the app, we'll define string constants for these names. That way, if we want to change the name of a component for some reason, we only have to change it in once place.
"""

# APP_NAME = "ccl-db-message-frequencies"
HIGH_LEVEL_GRAPH = "msgfreqs-high-level-graph"
DETAILED_GRAPH = "msgfreqs-detailed-graph"
# OPEN_DAY_BUTTON = "open-day-button"
OPEN_DAY_ANCHOR = "msgfreqs-open-day-anchor"

# OPEN_DAY_TEMPLATE = "Open {} on CCL"

"""## Define functions that create the figures"""

def create_empty_graph():
    return px.scatter()

def create_high_level_graph():
    return px.bar(df_monthly, x="date", y="count")

"""## Define helper functions for the app callbacks"""

def get_lowest_date_info(selected_data):
    """Supply year, month, day for the earliest date in selected_data.
    
    () --> tuple[Optional[int], Optional[int], Optional[int]]
    
    (year, month, day)

    selected_data is of the type returned by an `Input(..., "selectedData")`
    callback.
    
    """
    try:
        pts = selected_data["points"]
    except:
        return None, None, None

    if len(pts):
        d = min(p["x"] for p in pts)

        # Running the data points through `min` converts to yyyy-mm-dd strings
        return d.split("-")
    else:
        return None, None, None

"""## Define the app"""

# Create app and app layout
# app = Dash("ccl-db-message-frequencies")
layout = dhtml.Div([
    dhtml.H1("CCL.NET Message Posting Frequency"),
    dhtml.Div([
        dhtml.P("Hover over a chart to show controls."),
        dhtml.P(
            "Zoom (magnifying glass) and pan (up/down/left/right arrow) "
            "to the area of interest, then select a range of bars "
            "(dotted rectangle) to populate the posts-per-day chart below."
        )]),
    dhtml.H2("Posts Per Month (Full Archive)"),
    dcc.Graph(id=HIGH_LEVEL_GRAPH, figure=create_high_level_graph()),
    dhtml.H2("Posts Per Day (Selected Range)"),
    dhtml.Div([
        dhtml.P("Use the same zoom/pan/select controls as above."),
        dhtml.P(
            "After selecting some data, clicking the link below "
            "will take you to the day page on CCL for the first day "
            "in that range."
        ),
    ]),
    dhtml.Div([
        dhtml.A("App loading...", id=OPEN_DAY_ANCHOR, target="_blank", href=""),
    ]),
    dcc.Graph(id=DETAILED_GRAPH, figure=create_empty_graph()),
])

# Callback for populating the detailed plot
@callback(
    Output(DETAILED_GRAPH, "figure"),
    Input(HIGH_LEVEL_GRAPH, "selectedData"),
)
def set_detail_figure(hi_data):
    """Populate the detailed figure from the high-level selection."""
    try:
        pts = hi_data["points"]
    except:
        return create_empty_graph()

    if len(pts):
        min_date = min(p["x"] for p in hi_data["points"])
        max_date = max(p["x"] for p in hi_data["points"])

        # All months' dates are for the first day of the month.
        # We have to shift max_date to the last day of the month.
        md = pd.Timestamp(max_date)
        md = pd.Timestamp(
            year=md.year,
            month=md.month,
            day=calendar.monthrange(year=md.year, month=md.month)[1]
        )
        max_date = f"{md.year}-{md.month:0>2}-{md.day:0>2}"

    else:
        # Filters that return *no* data, so the chart will be blank
        # whenever no selection has been made
        min_date = 0
        max_date = 1
  
    df = df_daily[df_daily["date"] >= min_date]
    df = df[df["date"] <= max_date]

    return px.bar(df, x="date", y="count")


# Callback for updating the outbound day-page anchor href
@callback(
    Output(OPEN_DAY_ANCHOR, "href"),
    Input(DETAILED_GRAPH, "selectedData"),
)
def update_day_page_anchor_href(detail_data):
    year, month, day = get_lowest_date_info(detail_data)

    if year:
        return f"http://ccl.net/cgi-bin/ccl/day-index.cgi?{year}+{month:0>2}+{day:0>2}"
    else:
        return "http://ccl.net/chemistry/resources/messages/index.shtml"


# Callback for updating the outbound day-page anchor text
@callback(
    Output(OPEN_DAY_ANCHOR, "children"),
    Input(DETAILED_GRAPH, "selectedData"),
)
def update_day_page_anchor_text(detail_data):
    year, month, day = get_lowest_date_info(detail_data)

    if year:
        return f"Open {year}-{month:0>2}-{day:0>2} on CCL"
    else:
        return dhtml.Em("(Nothing selected)")

"""## Display the app"""

# print("Click the below '127.0.0.1' link to launch the app.\n")
# app.run_server(mode="inline", host="localhost", port=2185)


# layout = app.layout



# if __name__ == "__main__":
#     app.run()
    